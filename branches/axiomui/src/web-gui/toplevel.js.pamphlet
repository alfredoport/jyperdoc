\documentclass{article}
\usepackage{noweb}

\begin{document}

\title{toplevel.js}
\author{Kai Kaminski}
\maketitle
\section{Code}

This file contains all Javascript code for the Axiom toplevel
page. Other files that are related to that page include {\tt
TOPLEVEL.LISP} and {\tt TOPLEVEL.CSS}.

\subsubsection{makeCLString}
The function {\tt makeCLString} takes a string and escapes all
double-quotes ("), so that the Lisp reader is not confused. The proper
way to deal with this might be changing CL-AJAX.
<<makeCLString>>=
function makeCLString(string) {
  newString = "\""
  for (var i =0; i < string.length; i++) {
    if (string[i] == "\"") {
      newString = newString + "\\\""
    } else {
      newString = newString + string[i];
    }
  }
  return newString + '"';
}
@


\subsubsection{axiom\_eval}
The function {\tt axiom\_eval} is called when the user submitted
input. It sends the user's input to the server using {\tt
ajax\_toplevel\_eval}, which is auto-generated by CL-AJAX and calls {\tt
TOPLEVEL-EVAL} in {\tt TOPLEVEL.LISP} on the Lisp side. The callback
function is set to {\tt display\_result} (see below).

This function should be modified, so that the user can't submit new
input until the result for the last command arrived.
<<axiomEval>>=
function axiom_eval() {
  var input = document.getElementById('input');
  var command = input.value;
  input.value = "";

  var output_div = document.getElementById('output');

  var input_div = document.createElement('tt');
  input_div.setAttribute('class','axiomInput');
  input_div.appendChild(document.createTextNode(command));
  output_div.appendChild(input_div);

  ajax_toplevel_eval(display_result, true, null, null, makeCLString(command), session_id);
}
@


\subsubsection{display\_result}
This function is called as soon as the result for a command sent by
{\tt axiom\_eval} arrived. The parameter {\tt response} contains the
result as an XML document.

First of all the elements of the response, i.e. tex formatted math
output, type information and plot data, is extracted from the
response. Then a container element is added to the output area and
finally the parts of the response are processed and appended to the
container.

The final step is to scroll to the bottom of the window, which doesn't
always work properly.
<<displayResult>>=
function display_result(response) {
  var doc = response.documentElement;
  var texEls = doc.getElementsByTagName('tex');
  var typeEls = doc.getElementsByTagName('type');
  var plotEls = doc.getElementsByTagName('plot');

  var output_div = document.getElementById('output');

  var container = document.createElement('div');
  container.setAttribute('class','container');

  output_div.appendChild(container);

  <<plot>>

  <<tex>>

  <<type>>

  window.scrollTo(0, document.height);
  return false;
}
@ 

\subsubsection{plot}
If there is plot data then an {\tt OBJECT} element, which points to the URL
of the plot, is added to the container.
<<plot>>=
  if (plotEls.length) {
    var plot_el = plotEls.item(0);

    var url = plot_el.getAttribute('src');
    var width = plot_el.getAttribute('width');
    var height = plot_el.getAttribute('height');

    var plot_div = document.createElement('object');
    plot_div.setAttribute('data', url);
    plot_div.setAttribute('type', 'image/svg+xml');
    plot_div.setAttribute('style', 'width:' + (width + 1) + 'cm;height:' + (height + 1) +'cm;');
    container.appendChild(plot_div);
  }
@ 


\subsubsection{tex}
If there is a math result, a {\tt DIV} element is added to the container
element and then rendered using jsMath.
<<tex>>=
  if (texEls.length != 0) {
    var tex_el = texEls.item(0);
    var tex = tex_el.firstChild.data;

    var tex_div = document.createElement('div');
    tex_div.setAttribute('class','axiomTex');
    tex_div.appendChild(document.createTextNode(tex));
    container.appendChild(tex_div);
    jsMath.ProcessElement(tex_div);
  }
@ 

\subsubsection{type}
Last but not least the type information is wrapped in a {\tt TT}
element and appended to the container.
<<type>>=
  if (typeEls.length) {
    var type_el = typeEls.item(0);
    var type = type_el.firstChild.data;
    var type_div = document.createElement('tt');
    type_div.setAttribute('class','axiomType');
    type_div.appendChild(document.createTextNode("Type: " + type));
    container.appendChild(type_div);
  }
@ 

<<*>>=
<<makeCLString>>
<<axiomEval>>
<<displayResult>>
/*
<<license>>
*/
@

\section{License}
<<license>>=
Copyright (c) 2005, Kai Kaminski
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@ 
\end{document}